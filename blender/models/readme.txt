Ограничения:
Если одному объекту назначено более одного материала, то объект генерируется с "Vertex color attribute"


--------------------------
Формат модели:

4 байта - заголовок файла "BDM2"

4 байта - кол-во мешей (meshes)

meshes * (tmeshes) байт - атрибуты мешей (не сами данные):
{
	1 байт - тип и атрибуты меша X:
		байт 0:
			бит 0 - TRIANGLE[0]/QUAD[1]
			бит 1 - Vertex texture coordinate attribute
			бит 2 - Vertex color attribute
			биты 3:4
				00 - кол-во вершин меша 0..255		[VB]
			        01 - кол-во вершин меша 256..65535	[VS]
			        1x - кол-во вершин мена >65535		[VI]
			биты 5:6
				00 - кол-во индексов меша 0..255	[IB]
			        01 - кол-во индексов меша 256..65535	[IS]
			        1x - кол-во индексов мена >65535	[II]
[TBD]			бит 7 - тип данных 0 - HALF_FLOAT / 1 - FLOAT
	(1[VB], 2[VS] или 4[VI]) байт(а) - колво вершин меша ab[mesh]
	(1[IB], 2[IS] или 4[II]) байт(а) - колво индексов меша eab[mesh]
} tmeshes[meshes]

----
4 байта - "ANIM"
4 байта - кол-во кадров анимации (frames)

Данные кадра:
{
	1(meshes<256), 2(meshes<65536) или 4(meshes>65535) байт(а) - кол-во мешей в кадре (meshes_in_frame)
	meshes_in_frame * (t_mesh_inframe) - информация о кадре
	{
		1(meshes<256), 2(meshes<65536) или 4(meshes>65535 байт(а) - индекс меша X
		4 байта - RGBA материала 0 (если у объекта один материал)	(чувствуется избыточность для мешей которым не нужен материал)
	} t_mesh_inframe[meshes_in_frame]
} tframe[frames]

4 байта - "VBOD"

-- данные для загрузки в vbo
{
	ab[mesh] байт - буффер вершин и атрибутов вершин (Array buffer) *
	eab[mesh] байт - буффер индексов (Element array buffer) **
} mesh_data[meshes]

Примечания
* Формат хранения данных вершин, нормалей и текстурных координат - HALF_FLOAT (16 бит), цвета - 4x8 байт
** Формат хранения данных индексов зависит от количества вершин: (VB: BYTE, VS: SHORT, VI: INT)

-----------------
Дальнейшие идеи:
-----------------
Перейти на blender 2.5 (Там стоооко вкусного, хоть и бета но есть вкусняшки ради которых стоит перейти)

--------------------------
Оптимизации по количесту и объему мешей:
Для анимации мешей отличающихся только матрицей преобразования (смещение, поворот масштаб) хранить только сам
меш и последовательность матриц преобразования (всетаки 16 флоатов на меш это того стоит).
Данные кадра могут выглядеть так:
{
	1(meshes<256), 2(meshes<65536) или 4(meshes>65535) байт(а) - кол-во мешей в кадре (meshes_in_frame)
	meshes_in_frame * (t_mesh_inframe) - информация о кадре
	{
		1(meshes<256), 2(meshes<65536) или 4(meshes>65535 байт(а) - индекс меша X
		4 байта - RGBA материала 0 (если у объекта один материал)	(чувствуется избыточность для мешей которым не нужен материал)
		16*4 байт - Матрица преобразования меша.
	} t_mesh_inframe[meshes_in_frame]
} tframe[frames]


Поглядеть чеэто.

http://www.opengl.org/registry/specs/EXT/bindable_uniform.txt

-----------------------------------------------------------
Запаковать нормаль в один float (а в идеале в HALF_FLOAT, гы...)

Поскольку нормаль единичная, то нам достаточно запаковать только первые две компоненты и знак nz 

Паковка: 
float nx         = 0.5 * ( n.x + 1 );       // remap from [-1,1] to [0,1]
float ny         = 0.5 * ( n.y + 1 );       // remap from [-1,1] to [0,1]
float floatValue = fract ( 100.0 * nx ) + ny / 1000.0;

if ( n.z < 0.0 )                            // floatValue cannot be greater than 101.0
    floatValue += 200;

Распаковка: 

bool	neg = false;

if ( floatValue > 102.0 )
{
    neg         = true;
    floatValue -= 100.0;
}

float nx = 2.0 * fract ( floatValue ) * 1000.0 - 1.0;
float ny = 2.0 * floor ( floatValue ) * 0.01 - 1.0;
vec3  n = vec3 ( nx, ny, sqrt ( 1.0 - nx * nx - ny * ny );

if ( neg )
    n.z = -n.z;
